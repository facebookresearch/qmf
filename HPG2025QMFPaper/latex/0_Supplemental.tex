\documentclass[acmtog,anonymous,review]{acmart}
% \acmSubmissionID{papers\_1532}
\acmSubmissionID{papers\_1996s1}


\usepackage{booktabs} % For formal tables
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{tikz}
\usepackage{nicematrix} % to illustrate real-time
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{multirow}
% \usepackage{cite}
% \usepackage{amsmath}
% \usepackage{amsfonts}
\usepackage{siunitx}
%\usepackage{hyperref}

\graphicspath{ {./images/} {./generated/} }

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}
\newsavebox{\codebox}
% TOG prefers author-name bib system with square brackets
\citestyle{acmauthoryear}
%\setcitestyle{nosort,square} % nosort to allow for manual chronological ordering



\usepackage[ruled]{algorithm2e} % For algorithms
\renewcommand{\algorithmcfname}{ALGORITHM}
\setlength{\algomargin}{0pt}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
%\SetAlCapNameFnt{\small}https://overleaf.thefacebook.com/project/6778e7795bc9a40e2bfdb80e
\SetAlCapHSkip{0pt}

% Metadata Information
%\acmJournal{TOG}https://overleaf.thefacebook.com/project/6778e7795bc9a40e2bfdb80e


\input{Commands.tex}

% Document starts
\begin{document}
\setlength{\abovecaptionskip}{0.5ex}
\setlength{\belowcaptionskip}{0.5ex}
\setlength{\floatsep}{0.5ex}
\setlength{\textfloatsep}{0.5ex}

\title{Supplemental Material for QMF-Blend: Quantized Matrix Factorization for Efficient Blendshape Compression}


\section{Supplemental Material}
\begin{figure}
    \includegraphics[width=\linewidth]{chooseAlpha.pdf}
    \caption{Choosing $\alpha$ (Bowen model).}
    \label{fig:chooseAlpha}
\end{figure}


\begin{lrbox}{\codebox}
\begin{lstlisting}[language=c++, basicstyle=\scriptsize]
template <typename BlendShapeData, typename ValueType>
void computeSparseFactorizationBlendshapes(
    const BlendShapeData& data,
    DeviceSpan<const Vec3>& staticMeshCoords,
    DeviceSpan<Vec3>& outMeshCoords) {
  constexpr bool isQuantized = !std::is_floating_point_v<ValueType>;
  float bMult = data.bRange / std::numeric_limits<ValueType>::max();
  float cMult = data.cRange / std::numeric_limits<ValueType>::max();

  std::vector<float> matrixWB(data.numColumnB * 3lu, 0.f);
  uint32_t flatBIndex = 0;
  for (uint32_t bsIndex = 0; bsIndex < data.numBlendshapes; ++bsIndex) {
    float bsWeight = data.blendshapeWeights[bsIndex];
    for (uint32_t i = 0; i < 3; ++i) {
      uint32_t numValuesRow = data.matrixBNumValuesRow[bsIndex * 3 + i];
      for (uint32_t j = 0; j < numValuesRow; ++j) {
        float bValue = isQuantized ?
          data.bMin + bMult * data.matrixB[flatBIndex] : 
          data.matrixB[flatBIndex];
        uint32_t bCol = data.matrixBIndices[flatBIndex];
        matrixWB[3 * bCol + i] += bValue * bsWeight;
        flatBIndex++;
      }
    }
  }
 
  size_t numVertices = outMeshCoords.size();
  uint32_t flatCIndex = 0;
  for (uint32_t vIndex = 0; vIndex < numVertices; ++vIndex) {
    Vec3 res(0.f);
    uint_fast16_t numValuesCol = data.matrixCNumValuesCol[vIndex];
    for (uint_fast16_t i = 0; i < numValuesCol; ++i) {
      uint32_t cRow = data.matrixCIndices[flatCIndex + i];
      float cValue = isQuantized ?
        data.cMin + cMult * data.matrixC[flatCIndex + i] : 
        data.matrixC[flatCIndex + i];
      res.x += matrixWB[3 * cRow + 0] * cValue;
      res.y += matrixWB[3 * cRow + 1] * cValue;
      res.z += matrixWB[3 * cRow + 2] * cValue;
    }
    flatCIndex += data.matrixCNumValuesCol[vIndex];
    outMeshCoords[vIndex] = staticMeshCoords[vIndex] + res;
  }
}
\end{lstlisting}
\end{lrbox}

\begin{algorithm}
\caption{CPU code to apply sparse matrix factorization-based blendshapes at runtime.}
\label{alg:RuntimeCode}
\usebox{\codebox}
\end{algorithm}

\end{document}
