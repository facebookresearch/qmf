\section{Conclusion \& Future Work}
We have presented a novel blendshape compression algorithm that offers a significant improvement in terms of storage efficiency and computational performance for facial animation. By leveraging sparse matrix factorization, a new loss function, and quantization techniques, we are able to achieve higher compression ratios without sacrificing the essential features of the original blendshapes. This work has important implications for the development of more efficient and effective facial animation systems, enabling the creation of more realistic and engaging virtual characters.  These features should provide benefit in almost any scenario requiring facial animation, but will be especially useful for low-power and low-memory devices like those used for augmented reality.

One trade-off with our technique is that we need new run-time kernels, as standard linear blend skinning routines cannot be used.  However the algorithm is quite simple, and requires only small modifications and a small amount of additional data to enable the algorithm to become amenable to parallel processing (\Algorithm{alg:CudaCode}).

Additionally, the outcome of optimization is somewhat dependent on initial random seeds (\csfb shares this trait).  We have found, however, that once on the optimization path, convergence trajectory is somewhat predictable (see \Figure{fig:InitErrors}), which allows us to run several optimization steps with different random seeds, choose the best one, and continue optimizing with only that seed.  In practice this makes the process highly reliable while keeping optimization time reasonable.  It may be that future work can find a better way to select/cull random values in the matrices, leading to even more robust results with less computation.

One limitation of our work is that we have three hyperparameters that require per-model tuning: $\alpha$, how influential the Laplacian term is in our loss function, $\gamma$, how strong the influence of the wrinkles map is, and $\numNonzeroBC$, the number of non-zero values in the $\matB$ and $\matC$ matrices.  Future work could explore ways to automatically derive these based on desired compression vs quality.

Finally, while our wrinkles map technique does a very good job of driving non-zero values to visually important portions of the matrices, it would be interesting to investigate whether a more principled approach might be possible.
